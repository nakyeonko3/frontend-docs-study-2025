# 조건부 렌더링

- null은 JSX 상에서 렌더링 되지 않는다.
- 삼항 연산자로 조건부 렌더링하기
- &&를 왼쪽에 숫자를 두면 안된다.
  - 왼쪽 숫자가 0일 때 0이 화면에 렌더링 된다.

```
 <li>의 두 가지 다른 “인스턴스”를 만들 수 있기 때문에 객체 지향 프로그래밍에서는 위의 두 예가 미묘하게 다르다고 생각할 수 있습니다. 그러나 JSX 엘리먼트는 내부 상태를 보유하지 않으며 실제 DOM 노드가 아니기 때문에 “인스턴스”가 아닙니다. 이것은 청사진처럼 간단한 설명입니다. 따라서 위의 두 가지 예시 코드는 실제로 완전히 동일합니다. 상태를 보존하고 초기화하기에서는 이 기능이 어떻게 작동하는지 자세히 설명합니다.
```

## 자바스크립트 조건문 유의해야 될 점

- JavaScript에서 falsy로 취급되는 값들
  - `0, '', null, undefined, false` 
- truthy로 취급되는 값들
  - `{}, [], -1, '가', '0', true`
- `&&`는 falsy, `||`는 truthy가 되는 값을 리턴한다.

# 리스트 렌더링

## 배열을 데이터로 렌더링하기 
- map과 filter 사용하기
-  고유하게 식별할 수 있는 문자열 또는 숫자를 key로 지정하기
- map() 호출 내부의 JSX 엘리먼트에는 항상 key가 필요하다


- list 요소에 key값이 없는 경우 아래와 같은 경고가 표시된다.
```
Each child in a list should have a unique "key" prop.

Check the render method of `List`. See https://react.dev/link/warning-keys for more information. Stack: 
```

## key를 가져오는 곳
- 데이터베이스의 데이터에 사용되는 ID 값을 사용하기.
  - key/ID 값을 사용하기
  - 컴포넌트명과 같이 사용하기 `컴포넌트명-{ID}` 
- 로컬에서 생성된 데이터라면 `crypto.randomUUID()` 또는 `uuid` 사용하기

## key규칙
- 같은 배열(같은 형제 컴포넌트) 상에서는 key값을 사용한다

# 컴포넌트를 순수하게 유지하기

## 순수성: 공식으로서의 컴포넌트
-  순수 함수
	- 같은 입력(같은 매개변수 값)에 대해 동일한 출력을 보장해야 한다.
	- 함수 내부에서 외부의 상태를 변경해서는 안된다.
- React의 모든 컴포넌트는 순수 함수일 거라 가정한다.
- 즉 **React 컴포넌트에 같은 입력이 주어지면 같은 JSX를 반환**한다.

- y = 2x
```jsx
function double(number) {
  return 2 * number;
}
```

## 사이드 이펙트: 의도하지 않은 결과
- 컴포넌트 외부에 선언된 값을 변경하는 경우
- strict mode
	- 컴포넌트를 의도적으로 두 번 호출하여 값을 비교한다.
	- 이때 두 값이 다르면 순수하지 않은 함수이다.
## 지역 변경: 컴포넌트의 작은 비밀 
- 컴포넌트 내부 변수값을 변경하는 것은 허용된다.



## 사이드 이펙트를 _일으킬 수 있는_ 지점
- [React의 규칙 – React](https://ko.react.dev/reference/rules)
- 사이드 이펙트 
	- fetch를 통해 데이터를 가져오는 경우
	- 파일에 데이터를 쓰는 경우
	- 화면에 무언가를 입력하는 경우
- 사이드 이펙트는 이벤트 헨들러 내부에 작성한다.
	- 컴포넌트 렌더링할 때 바로 실행되지 않고, 사용자의 상호작용에 의해 브라우저 이벤트 루프에 의해 실행된다.
	- ex) 버튼 클릭 이벤트 헨들러 함수가 onClick 매개변수로 전달되고 있으면, 해당 이벤트 헨들러 함수가 있는 컴포넌트가 렌더링될 때 즉시 실행되는게 아니라 클릭 이벤트 발생시에 이벤트 헨들러 함수가 호출된다.
- 그래도 안되면 `useEffect` 를 사용한다.
	- `useEffect`는 React가 **렌더링 후에** 부수 효과를 실행한다.
- React는 왜 순수함아 중요할까?
	- 입력이 같으면 출력도 같기 때문에 **서버, 클라이언트 환경에서 실행되어도 동작을 예측할 수 있다.**
	- 동일한 입력에 대해 메모리제이션을 통해 계산을 생략할 수 있다.
	- 오래걸리는 작업이나 데이터가 패칭을 할 때 렌더링을 중단하고 다시 렌더링하더라도 큰 문제가 없다. <- ?